<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@1.0.0-next.13 C:\Users\jerza\OneDrive\Pulpit\projects\threlte-fps-example\static\models\scene.gltf --root /models/ --types --printwidth 120 --precision 2
Author: BillyTheKid (https://sketchfab.com/FGmodels)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/m4a1-with-hands-and-animations-79524d1b74e24962979127cbb5c0b55b
Title: M4A1 With Hands And Animations
-->

<script lang="ts">
	import {
		T,
		type Props,
		type Events,
		type Slots,
		forwardEventHandlers,
		useFrame
	} from '@threlte/core';
	import { useGltf, useGltfAnimations, useTexture } from '@threlte/extras';
	import { rendererStores } from '$lib/renderer/rendererStores';
	import { cameraStores } from '$lib/renderer/cameraStores';
	import { tweened } from 'svelte/motion';
	import { quadInOut } from 'svelte/easing';
	import * as THREE from 'three';
	import { DEG2RAD } from 'three/src/math/MathUtils';
	import { useKeyboardControls } from 'svelte-kbc';
	import { gunStores } from '$lib/gun/gunStores';
	import ScopeShaderMaterial from '$lib/shaders/ScopeShaderMaterial.svelte';

	type $$Props = Props<THREE.Group> & {
		startPosition: THREE.Vector3;
		endPosition: THREE.Vector3;
		shooting: boolean;
	};
	type $$Events = Events<THREE.Group>;
	type $$Slots = Slots<THREE.Group> & { fallback: {}; error: { error: any } };

	export const ref = new THREE.Group();
	export let shooting = false;

	let holoGroup: THREE.Group;

	type ActionName =
		| 'h2_skeleton|draw'
		| 'h2_skeleton|draw2'
		| 'h2_skeleton|fire1'
		| 'h2_skeleton|fire11'
		| 'h2_skeleton|fire2'
		| 'h2_skeleton|fire3'
		| 'h2_skeleton|fire33'
		| 'h2_skeleton|idle'
		| 'h2_skeleton|idle2'
		| 'h2_skeleton|reload'
		| 'h2_skeleton|reload2'
		| 'h2_skeleton|ss'
		| 'h2_skeleton|ss2';
	type GLTFResult = {
		nodes: {
			Object_10: THREE.SkinnedMesh;
			Object_11: THREE.SkinnedMesh;
			Object_12: THREE.SkinnedMesh;
			Object_13: THREE.SkinnedMesh;
			Object_15: THREE.SkinnedMesh;
			Object_16: THREE.SkinnedMesh;
			Object_17: THREE.SkinnedMesh;
			Object_18: THREE.SkinnedMesh;
			Object_19: THREE.SkinnedMesh;
			Object_20: THREE.SkinnedMesh;
			Object_21: THREE.SkinnedMesh;
			Object_22: THREE.SkinnedMesh;
			_rootJoint: THREE.Bone;
		};
		materials: {
			sleeve_col: THREE.MeshStandardMaterial;
			glove_col: THREE.MeshStandardMaterial;
			alpha_col: THREE.MeshStandardMaterial;
			digit_anim: THREE.MeshStandardMaterial;
			lense_col: THREE.MeshStandardMaterial;
			eotech_col: THREE.MeshStandardMaterial;
			magnifier_col: THREE.MeshStandardMaterial;
			lens_col: THREE.MeshStandardMaterial;
			m4_col: THREE.MeshStandardMaterial;
			sm_col: THREE.MeshStandardMaterial;
			foregrip_col: THREE.MeshStandardMaterial;
			suppressor_col: THREE.MeshStandardMaterial;
		};
	};

	const gltf = useGltf<GLTFResult>('/models/m4.gltf');
	export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);

	const component = forwardEventHandlers();

	let scale = 0.01;

	const cg = new THREE.SphereGeometry(0.5, 5, 5);
	const cm = new THREE.MeshBasicMaterial({ color: 'red', wireframe: false });

	const bStartMesh = new THREE.Mesh(cg, cm);
	const bEndMarker = new THREE.Mesh(cg, cm);
	const sStartMarker = new THREE.Mesh(cg, cm);
	const sEndMarker = new THREE.Mesh(cg, cm);

	bStartMesh.visible = false;
	bEndMarker.visible = false;
	sEndMarker.visible = false;
	sStartMarker.visible = false;

	let gunRef: any;
	let x2Ref: any;

	let initialized = false;
	$: {
		if (gunRef && x2Ref && !initialized) {
			const bone = gunRef.skeleton.getBoneByName('tag_weapon_04');
			const eo = gunRef.skeleton.getBoneByName('tag_ads_02');

			bStartMesh.position.x = 25;
			bStartMesh.position.z = 2.6;
			bEndMarker.position.x = 4;
			bEndMarker.position.z = 2.6;

			sEndMarker.position.x = 7;
			sEndMarker.position.z = 5.5;
			sStartMarker.position.x = -3;
			sStartMarker.position.z = 5.5;

			bone.add(bStartMesh);
			bone.add(bEndMarker);
			bone.add(sStartMarker);
			bone.add(sEndMarker);
			initialized = true;

			bone.add(holoGroup);
		}
	}

	const { scopeToggle, reload } = useKeyboardControls();

	let x2 = false;
	let silencer = false;
	let gunDrawn = true;

	// $: console.log({ x2, reloading, swappingScope, shooting, gunDrawn });

	$: shootAnimation(shooting);

	const shootAnimation = (shooting: boolean) => {
		if (shooting) {
			if (x2) {
				$actions['h2_skeleton|fire1']?.reset();
				$actions['h2_skeleton|fire1']
					?.setLoop(THREE.LoopRepeat, 1)
					.setEffectiveWeight(0.75)
					.setEffectiveTimeScale(0.9)
					.play();
			} else {
				$actions['h2_skeleton|fire33']?.reset();
				$actions['h2_skeleton|fire33']
					?.setLoop(THREE.LoopRepeat, 1)
					.setEffectiveWeight(0.75)
					.setEffectiveTimeScale(0.9)
					.play();
			}
		} else {
			$actions['h2_skeleton|idle2']?.play();
		}
	};

	$: a = {
		idle: $actions['h2_skeleton|idle'],
		idle2: $actions['h2_skeleton|idle2'],
		ss: $actions['h2_skeleton|ss'],
		ss2: $actions['h2_skeleton|ss2'],
		reload: $actions['h2_skeleton|reload'],
		reload2: $actions['h2_skeleton|reload2'],
		draw: $actions['h2_skeleton|draw'],
		draw2: $actions['h2_skeleton|draw2'],
		fire1: $actions['h2_skeleton|fire1'],
		fire11: $actions['h2_skeleton|fire11'],
		fire2: $actions['h2_skeleton|fire2'],
		fire3: $actions['h2_skeleton|fire3'],
		fire33: $actions['h2_skeleton|fire33']
	};

	const playAnim = (
		animationName: keyof typeof a,
		options = {
			repeat: 0,
			duration: 0
		}
	) => {
		Object.values(a).map((anim) => {
			anim?.stop();
			anim?.reset();
		});
		const animation = a[animationName];
		if (!animation) return;

		if (options.repeat > 0) animation.setLoop(THREE.LoopRepeat, 1);
		if (options.duration > 0) animation.setDuration(options.duration);
		animation.play();
	};

	const idleAnim = () => {
		if (x2) {
			playAnim('idle');
		} else {
			playAnim('idle2');
		}
	};

	let reloading = false;
	let swappingScope = false;

	const swapScope = (swapScopeToggle: boolean) => {
		const duration = 4;

		const canSwap = !shooting && !reloading && gunDrawn && !swappingScope;
		if (swapScopeToggle && canSwap) {
			swappingScope = true;
			const options = { duration, repeat: 1 };
			if (x2) {
				playAnim('ss2', options);
			} else {
				playAnim('ss', options);
			}
			x2 = !x2;
			setTimeout(() => {
				swappingScope = false;
				idleAnim();
			}, duration * 1000);
		}
	};

	$: swapScope($scopeToggle);

	$: reloadAnimation($reload);
	const reloadAnimation = (reload: boolean) => {
		const duration = 4;

		const canReload = !shooting && !reloading && gunDrawn && !swappingScope;
		if (reload && canReload) {
			reloading = true;
			const options = { duration, repeat: 1 };
			if (x2) {
				playAnim('reload', options);
			} else {
				playAnim('reload2', options);
			}
			setTimeout(() => {
				reloading = false;
				idleAnim();
			}, duration * 1000);
		}
	};

	$: {
		if (a.idle && a.idle2) {
			idleAnim();
		}
	}

	export let startPosition = new THREE.Vector3();
	export let endPosition = new THREE.Vector3();

	const sightsStart = new THREE.Vector3();
	const sightsEnd = new THREE.Vector3();

	const { sightsQuat, sightsPosition } = cameraStores;

	const sightsRotationHelper = new THREE.Mesh();

	useFrame(({ clock }) => {
		// x2material.needsUpdate = true;
		bStartMesh.getWorldPosition(startPosition);
		bEndMarker.getWorldPosition(endPosition);
		sStartMarker.getWorldPosition(sightsStart);
		sEndMarker.getWorldPosition(sightsEnd);

		sightsRotationHelper?.position.set(...sightsEnd.toArray());
		sightsRotationHelper.lookAt(...sightsStart.toArray());

		$sightsPosition.copy(sightsStart);
		$sightsQuat.setFromEuler(sightsRotationHelper.rotation);
	});

	let aimOffsetX = 3;
	let aimOffsetY = 0.38;
	let aimOffsetZ = -5;

	window.addEventListener('wheel', (e) => {
		aimOffsetZ += e.deltaY * 0.003;
		aimOffsetZ = Math.max(aimOffsetZ, -7);
		aimOffsetZ = Math.min(aimOffsetZ, 5);
	});

	const { activeCamera, sightsRenderTarget } = rendererStores;
	const cameraSwapTween = tweened(0);

	$: {
		if ($activeCamera === 'eyes') {
			cameraSwapTween.set(0, {
				easing: quadInOut,
				duration: 200
			});
		}

		if ($activeCamera === 'sights') {
			cameraSwapTween.set(1, {
				easing: quadInOut,
				duration: 300
			});
		}
	}

	const { gunObject3D } = gunStores;

	gunObject3D.set(ref);
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Group
			name="Sketchfab_Scene"
			frustumCulled={false}
			position={[
				aimOffsetX * $cameraSwapTween,
				aimOffsetY * $cameraSwapTween,
				aimOffsetZ * $cameraSwapTween
			]}
		>
			<T.Group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]} frustumCulled={false}>
				<T.Group
					name="ab25487b58b043d09a956bcac5cbf842fbx"
					rotation={[Math.PI / 2, 0, 0]}
					{scale}
					frustumCulled={false}
				>
					<T.Group name="Object_2" frustumCulled={false}>
						<T.Group name="RootNode">
							<T.Group name="h2" rotation={[-Math.PI / 2, 0, 0]} scale={100} />
							<T.Group name="m4a1" rotation={[-Math.PI / 2, 0, 0]} scale={100} />
							<T.Group name="h2_skeleton" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
								<T.Group name="Object_7">
									<T is={gltf.nodes._rootJoint} />
									<T.Group name="Object_9" rotation={[-Math.PI / 2, 0, 0]} scale={100} />
									<T.Group name="Object_14" rotation={[-Math.PI / 2, 0, 0]} scale={100} />

									<T.SkinnedMesh
										name="Arms"
										geometry={gltf.nodes.Object_10.geometry}
										material={gltf.materials.sleeve_col}
										skeleton={gltf.nodes.Object_10.skeleton}
										frustumCulled={false}
									/>
									<T.SkinnedMesh
										name="Hands"
										geometry={gltf.nodes.Object_11.geometry}
										material={gltf.materials.glove_col}
										skeleton={gltf.nodes.Object_11.skeleton}
										frustumCulled={false}
									/>
									<T.SkinnedMesh
										name="Watch"
										geometry={gltf.nodes.Object_12.geometry}
										material={gltf.materials.alpha_col}
										skeleton={gltf.nodes.Object_12.skeleton}
										frustumCulled={false}
									/>
									<T.SkinnedMesh
										name="Object_13"
										geometry={gltf.nodes.Object_13.geometry}
										material={gltf.materials.digit_anim}
										skeleton={gltf.nodes.Object_13.skeleton}
										frustumCulled={false}
									/>

									<T.Group
										scale={0.2}
										rotation.x={DEG2RAD * 90}
										rotation.y={DEG2RAD * 90}
										bind:ref={holoGroup}
										position.x={6}
										position.y={0}
										position.z={5.45}
									>
										<T.Mesh>
											<T.TorusGeometry args={[0.72, 0.04, 10, 30]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
										<T.Mesh>
											<T.SphereGeometry args={[0.06]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
										<T.Mesh position.x={0.8}>
											<T.PlaneGeometry args={[0.25, 0.08]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
										<T.Mesh position.x={-0.8}>
											<T.PlaneGeometry args={[0.25, 0.08]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
										<T.Mesh position.y={-0.8}>
											<T.PlaneGeometry args={[0.08, 0.24]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
										<T.Mesh position.y={0.8}>
											<T.PlaneGeometry args={[0.08, 0.24]} />
											<T.MeshBasicMaterial side={THREE.DoubleSide} color={'#ef4400'} />
										</T.Mesh>
									</T.Group>
									<!-- <T.SkinnedMesh
										name="viewer_holo"
										geometry={gltf.nodes.Object_15.geometry}
										skeleton={gltf.nodes.Object_15.skeleton}
										frustumCulled={false}
									/> -->
									<T.SkinnedMesh
										name="holo"
										geometry={gltf.nodes.Object_16.geometry}
										material={gltf.materials.eotech_col}
										skeleton={gltf.nodes.Object_16.skeleton}
										frustumCulled={false}
									/>
									<T.SkinnedMesh
										name="scope_2x"
										geometry={gltf.nodes.Object_17.geometry}
										material={gltf.materials.magnifier_col}
										skeleton={gltf.nodes.Object_17.skeleton}
										frustumCulled={false}
										bind:ref={x2Ref}
									/>
									<T.SkinnedMesh
										name="viewer_2x"
										geometry={gltf.nodes.Object_18.geometry}
										skeleton={gltf.nodes.Object_18.skeleton}
										frustumCulled={false}
									>
										<ScopeShaderMaterial />
									</T.SkinnedMesh>
									<T.SkinnedMesh
										name="gun"
										geometry={gltf.nodes.Object_19.geometry}
										material={gltf.materials.m4_col}
										skeleton={gltf.nodes.Object_19.skeleton}
										frustumCulled={false}
										bind:ref={gunRef}
									/>
									<T.SkinnedMesh
										name="charging_handle"
										geometry={gltf.nodes.Object_20.geometry}
										material={gltf.materials.sm_col}
										skeleton={gltf.nodes.Object_20.skeleton}
										frustumCulled={false}
									/>
									<T.SkinnedMesh
										name="Object_21"
										geometry={gltf.nodes.Object_21.geometry}
										material={gltf.materials.foregrip_col}
										skeleton={gltf.nodes.Object_21.skeleton}
										frustumCulled={false}
									/>
									<!-- <T.SkinnedMesh
										name="Silencer"
										geometry={gltf.nodes.Object_22.geometry}
										material={gltf.materials.suppressor_col}
										skeleton={gltf.nodes.Object_2`2.skeleton}
										frustumCulled={false}
									/> -->
								</T.Group>
							</T.Group>
						</T.Group>
					</T.Group>
				</T.Group>
			</T.Group>
		</T.Group>
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
